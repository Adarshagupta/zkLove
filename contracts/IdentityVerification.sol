// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./verifier.sol"; // This would be generated by your ZK circuit compiler

/**
 * @title IdentityVerification
 * @dev Smart contract for storing and verifying zero-knowledge identity proofs
 */
contract IdentityVerification {
    // Verifier contract for ZK proofs
    Verifier public immutable verifier;
    
    // Events
    event ProofSubmitted(
        address indexed user,
        bytes32 indexed proofHash,
        uint256 timestamp
    );
    
    event VerificationStatusChanged(
        address indexed user,
        bool verified,
        uint256 timestamp
    );

    // Struct to store verification data
    struct VerificationData {
        bytes32 proofHash;
        uint256 timestamp;
        bool isValid;
        bool exists;
    }

    // Mapping from user address to their verification data
    mapping(address => VerificationData) public verifications;
    
    // Mapping from proof hash to user address (for reverse lookup)
    mapping(bytes32 => address) public proofToUser;
    
    // Array to store all verified users (for enumeration)
    address[] public verifiedUsers;
    
    // Total number of verified users
    uint256 public totalVerifiedUsers;

    /**
     * @dev Constructor
     * @param _verifier Address of the ZK proof verifier contract
     */
    constructor(address _verifier) {
        require(_verifier != address(0), "Invalid verifier address");
        verifier = Verifier(_verifier);
    }

    /**
     * @dev Submit a zero-knowledge proof for identity verification
     * @param proof The ZK proof as bytes
     * @param publicInputs Array of public inputs for the proof
     */
    function submitProof(
        bytes calldata proof,
        uint256[] calldata publicInputs
    ) external returns (bool) {
        require(proof.length > 0, "Empty proof");
        require(publicInputs.length > 0, "No public inputs");
        
        // Verify the ZK proof
        bool isValidProof = verifier.verifyTx(proof, publicInputs);
        require(isValidProof, "Invalid proof");
        
        // Generate proof hash
        bytes32 proofHash = keccak256(abi.encodePacked(proof, publicInputs, msg.sender));
        
        // Check if user is already verified
        if (verifications[msg.sender].exists) {
            // Update existing verification
            verifications[msg.sender].proofHash = proofHash;
            verifications[msg.sender].timestamp = block.timestamp;
            verifications[msg.sender].isValid = true;
        } else {
            // Create new verification record
            verifications[msg.sender] = VerificationData({
                proofHash: proofHash,
                timestamp: block.timestamp,
                isValid: true,
                exists: true
            });
            
            // Add to verified users array
            verifiedUsers.push(msg.sender);
            totalVerifiedUsers++;
        }
        
        // Store reverse mapping
        proofToUser[proofHash] = msg.sender;
        
        // Emit events
        emit ProofSubmitted(msg.sender, proofHash, block.timestamp);
        emit VerificationStatusChanged(msg.sender, true, block.timestamp);
        
        return true;
    }

    /**
     * @dev Check if a user is verified
     * @param user Address of the user to check
     * @return bool Whether the user is verified
     */
    function isVerified(address user) external view returns (bool) {
        return verifications[user].exists && verifications[user].isValid;
    }

    /**
     * @dev Get verification data for a user
     * @param user Address of the user
     * @return proofHash Hash of the submitted proof
     * @return timestamp When the proof was submitted
     * @return isValid Whether the verification is valid
     * @return exists Whether a verification record exists
     */
    function getVerificationData(address user) 
        external 
        view 
        returns (
            bytes32 proofHash,
            uint256 timestamp,
            bool isValid,
            bool exists
        ) 
    {
        VerificationData memory data = verifications[user];
        return (data.proofHash, data.timestamp, data.isValid, data.exists);
    }

    /**
     * @dev Get user address from proof hash
     * @param proofHash Hash of the proof
     * @return address Address of the user who submitted the proof
     */
    function getUserByProofHash(bytes32 proofHash) external view returns (address) {
        return proofToUser[proofHash];
    }

    /**
     * @dev Verify a specific proof hash exists and is valid
     * @param proofHash Hash of the proof to verify
     * @return bool Whether the proof exists and is valid
     */
    function verifyProofHash(bytes32 proofHash) external view returns (bool) {
        address user = proofToUser[proofHash];
        if (user == address(0)) {
            return false;
        }
        return verifications[user].isValid;
    }

    /**
     * @dev Get all verified users (paginated)
     * @param offset Starting index
     * @param limit Number of users to return
     * @return users Array of verified user addresses
     */
    function getVerifiedUsers(uint256 offset, uint256 limit) 
        external 
        view 
        returns (address[] memory users) 
    {
        require(offset < totalVerifiedUsers, "Offset out of bounds");
        
        uint256 end = offset + limit;
        if (end > totalVerifiedUsers) {
            end = totalVerifiedUsers;
        }
        
        uint256 length = end - offset;
        users = new address[](length);
        
        for (uint256 i = 0; i < length; i++) {
            users[i] = verifiedUsers[offset + i];
        }
        
        return users;
    }

    /**
     * @dev Revoke verification (only by the user themselves)
     * This might be needed for privacy or security reasons
     */
    function revokeVerification() external {
        require(verifications[msg.sender].exists, "No verification to revoke");
        
        // Mark as invalid but keep the record for audit purposes
        verifications[msg.sender].isValid = false;
        
        emit VerificationStatusChanged(msg.sender, false, block.timestamp);
    }

    /**
     * @dev Emergency function to revoke a verification (only owner)
     * This should only be used in case of proven fraud or security issues
     */
    function emergencyRevoke(address user) external {
        // In a real implementation, you'd want proper access control here
        // For now, anyone can call this (not recommended for production)
        require(verifications[user].exists, "No verification to revoke");
        
        verifications[user].isValid = false;
        
        emit VerificationStatusChanged(user, false, block.timestamp);
    }

    /**
     * @dev Get contract statistics
     * @return totalUsers Total number of users who have submitted proofs
     * @return validVerifications Number of currently valid verifications
     */
    function getStats() external view returns (uint256 totalUsers, uint256 validVerifications) {
        totalUsers = totalVerifiedUsers;
        validVerifications = 0;
        
        for (uint256 i = 0; i < totalVerifiedUsers; i++) {
            if (verifications[verifiedUsers[i]].isValid) {
                validVerifications++;
            }
        }
        
        return (totalUsers, validVerifications);
    }

    /**
     * @dev Check if a proof with specific public inputs would be valid
     * This is a view function that doesn't modify state
     * @param proof The ZK proof as bytes
     * @param publicInputs Array of public inputs for the proof
     * @return bool Whether the proof would be valid
     */
    function checkProofValidity(
        bytes calldata proof,
        uint256[] calldata publicInputs
    ) external view returns (bool) {
        if (proof.length == 0 || publicInputs.length == 0) {
            return false;
        }
        
        return verifier.verifyTx(proof, publicInputs);
    }
}
